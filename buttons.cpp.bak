#include <cstdlib>
#include <iomanip>
#include <thread>
#include <nlohmann/json.hpp>
#include <vector>
#include <string>
#include <algorithm>

#include "commons.h"
#include "buttons.h"


using json = nlohmann::json;

class Button;

Button::Button(CONFIG *config, CONF::Button *buttonConf, MyMqtt *myMqtt): withConfig(config, buttonConf), withMqtt(myMqtt) {

    this->setThreadSleepTimeMicro(100);
  

    this->lastState = STATE::OFF;
    this->clickCount = 0;
    this->clickType = CLICK_TYPE::NOCLICK;

    this->addActionHandler( [this](BUTTON_ACTION btAction, unsigned int clickCount) {
        json j;
        j["action"] = btAction_to_string(btAction);
        j["clickCount"] = clickCount;
        j["name"] = this->getName();
        j["comment"] = this->getComment();
        this->getMqtt()->publish(this->getDispatchTOPIC(), j, false);
    });

      /*if (this->getConfigT()->button_actions.size() > 0) {
        for (auto action: this->getConfigT()->button_actions) {
          this->addActionHandler([this, action](BUTTON_ACTION btAction, unsigned int clickCount){
            BUTTON_ACTION act = BUTTON_ACTION(action->event); //SIMPLECLICK, MULTICLICK, ...
            if (act == btAction) {
              if(action->event_actions.size() > 0) {
                for (auto evt_action: action->event_actions) {
                  json j;
                  j = json::parse(evt_action->action_params);
                  if (act == BUTTON_ACTION::MULTICLICK) {
                    if (action->clickCount == clickCount) {
                      j["clickCount"]= clickCount;
                      this->getMqtt()->publish(evt_action->action_topic, j, false);
                    }
                  } else {
                    this->getMqtt()->publish(evt_action->action_topic, j, false);
                  }
                }
              }
            }           
          });
        }
      }*/



      this->getMqtt()->addMessageArrivedHandler([this](std::string topic, std::string payload){
        if(topic == this->getListenTOPIC()) {
            json j = json::parse(payload);
            this->setCurState( state_from_string(j["state"].get<std::string>()) );
        }
      });
      // Params
      this->getMqtt()->addMessageArrivedHandler([this](std::string topic, std::string payload){
        if(topic == this->getSetTOPIC()) {
          json params = json::parse(payload);
          this->setBaseParams(params);
          if (params.contains("dcGap") && !params["dcGap"].empty()) {
              this->setDcGap(params["dcGap"].get<int>());
          }
          if (params.contains("holdTime") && !params["holdTime"].empty()) {
              this->setHoldTime(params["holdTime"].get<int>());
          }
          if (params.contains("listenTOPIC") && !params["listenTOPIC"].empty()) {
              this->setListenTOPIC(params["listenTOPIC"].get<std::string>());
          }
        }
      });

    //getConfiguration
    this->getMqtt()->addMessageArrivedHandler([this](std::string topic, std::string payload) {
        if (topic == this->getGetTOPIC()) {
            this->getMqtt()->publish(this->getDispatchTOPIC(), this->getConfigT()->getJsonConfig(this->getConfigT()), false);
        }
    });
}


std::string Button::getListenTOPIC() {
  return this->getConfigT()->listen_TOPIC;
}


void Button::setListenTOPIC(std::string l) {
  this->getConfigT()->listen_TOPIC = l;
  this->getConfig()->save();
}

BUTTON_TYPE Button::getType() {
  return this->getConfigT()->type;
}

void Button::setType(BUTTON_TYPE type){
  this->getConfigT()->type = type;
  this->getConfig()->save();
}


int Button::getDcGap() {
    return this->getConfigT()->DC_gap;
}

void Button::setDcGap(int ms) {
  this->getConfigT()->DC_gap = ms;
  this->getConfig()->save();
}

int Button::getHoldTime() {
  return this->getConfigT()->HOLD_time;
}

void Button::setHoldTime(int ms) {
  this->getConfigT()->HOLD_time = ms;
  this->getConfig()->save();  
}


void Button::setCurState(STATE curState) {
  this->curState = curState;
}

void Button::process() {
    STATE curState = this->curState; 
    //std::cout << "Button " << this->getName() << " curState value: " << curState << " btLastValue:" << this->lastState << std::endl;
    if( this->lastState == STATE::OFF && curState == STATE::ON ) {
      //std::cout << "Button " << this->getName() << " curState value: " << state_to_string(curState) << " btLastValue:" << state_to_string(this->lastState) << std::endl;
           //printf("front montant\r\n"); fflush(stdout);
            // *****************************   
            // traitement sur front montant
            // ***************************** 

            this->lastState = STATE::ON;
            
            this->pressedTime = std::chrono::steady_clock::now();

            //this->_onPressed();
            this->_onAction(BUTTON_ACTION::PRESSED, 0);  

        } else if( (this->lastState == STATE::ON) && (curState == STATE::OFF) ) {
          std::cout << "Button " << this->getName() << " curState value: " << state_to_string(curState) << " btLastValue:" << state_to_string(this->lastState) << std::endl;
            //printf("front descendant\r\n"); fflush(stdout);
            // ***************************** 
            // traitement sur front descendant
            // ***************************** 
            this->lastState = STATE::OFF;
            
            this->releasedTime = std::chrono::steady_clock::now();

            if (std::chrono::duration_cast<std::chrono::milliseconds>(this->releasedTime - this->pressedTime).count() < this->getDcGap()) {
                this->clickCount++;
                this->clickType = CLICK_TYPE::MULTICLICK;
            }

            //this->_onReleased(); 
            this->_onAction(BUTTON_ACTION::RELEASED, 0);   

            if (this->clickType == CLICK_TYPE::LONGCLICK) {
                //this->_onLongClickStop();
                this->_onAction(BUTTON_ACTION::LONGCLICKSTOP, 0);
            }
            
        } else if( (this->lastState == STATE::OFF) && (curState == STATE::OFF) ) {
           // printf("front bas\r\n"); fflush(stdout);
            // ***************************** 
            // pas de changement d'état : front bas
            // ***************************** 
            this->t0 = std::chrono::steady_clock::now();
            
            //Attendre DC_Gap pour connaitre le nombre de click      
            if (std::chrono::duration_cast<std::chrono::milliseconds>(this->t0 - this->releasedTime).count() > this->getDcGap()) {
                if (this->clickCount == 1) {
                  //LOG("SimpleClick");
                  this->clickType = CLICK_TYPE::SIMPLECLICK;
                  
                  //this->_onSimpleClick();
                  this->_onAction(BUTTON_ACTION::SIMPLECLICK, 1);
                } else if ( this->clickCount > 1 ) {
                    //LOG("MultiClick: %d",this->click_count);
                  this->clickType = CLICK_TYPE::MULTICLICK;
                  
                  //this->_onMultiClicks(this->clickCount);
                  this->_onAction(BUTTON_ACTION::MULTICLICK, this->clickCount);

                }
                this->clickType = CLICK_TYPE::NOCLICK;
                this->clickCount = 0;
            }
            
        } else if( (this->lastState == STATE::ON) && (curState == STATE::ON) ) {
           // printf("front haut\r\n"); fflush(stdout);
            // ***************************** 
            // pas de changement d'état : front haut
            // ***************************** 

            this->t1 = std::chrono::steady_clock::now();
        
            //long click
            if (std::chrono::duration_cast<std::chrono::milliseconds>(this->t1 - this->pressedTime).count() > this->getHoldTime() && this->clickType != CLICK_TYPE::LONGCLICK) {
                //LOG("LongClick START");
                this->clickType = CLICK_TYPE::LONGCLICK;
                //this->_onLongClickStart();
                this->_onAction(BUTTON_ACTION::LONGCLICKSTART, 0);
            }
        }
}

void Button::_onAction(BUTTON_ACTION btAction, unsigned int clickCount){
  for(auto&& handler : this->actionHandlers) {
    std::thread(handler, btAction, clickCount).detach();
  }
}


void Button::_onMainThreadStart() {
  std::cout << "Starting Button " << this->getName() << " thread..." << std::endl;
}

void Button::_onMainThreadStopping() {
  std::cout << "Stoping Button " << this->getName() << " thread..." << std::endl;  
}

void Button::_onMainThreadStop() {
  std::cout << "Button " << this->getName() << " stoped." << std::endl;  
}




void Button::addActionHandler(actionHandlersFunc function) {
    this->actionHandlers.push_back(function);
}


Button::~Button() {

}


/* ========================================== */
class Buttons;

Buttons::Buttons(CONFIG *config, MyMqtt *myMqtt) {

    for (auto buttonConf: config->getConfig()->buttons->buttons) {
      Button *bt = new Button(config, buttonConf, myMqtt);
   
      this->addButton(bt);
      std::cout << "Added Button name: " << bt->getName() << " comment: " << bt->getComment() << std::endl;
    }
}


void Buttons::addButton(Button* button) {
    this->buttons.push_back(button);
}


Button *Buttons::findByName(std::string name) {
    auto it = std::find_if(this->buttons.begin(), this->buttons.end(), [name](Button *obj) {return obj->getName() == name;});
    return *it;
}

void Buttons::dump() {
  for(std::vector<Button*>::iterator it = std::begin(this->buttons); it != std::end(this->buttons); ++it) {
    printf("Button %s, comment: %s\r\n",(*it)->getName(), (*it)->getComment()); fflush(stdout);
  }
}

void Buttons::startChildrenThreads() {
  std::cout << "Starting Buttons children thread..." << std::endl;
  for(std::vector<Button*>::iterator it = std::begin(this->buttons); it != std::end(this->buttons); ++it) {
    (*it)->start();
  } 
}

void Buttons::stopChildrenThreads() {
  std::cout << "Stoping Buttons children thread..." << std::endl;
  for(std::vector<Button*>::iterator it = std::begin(this->buttons); it != std::end(this->buttons); ++it) {
    (*it)->stop();
  } 
}

void Buttons::joinChildrenThreads() {
  for(std::vector<Button*>::iterator it = std::begin(this->buttons); it != std::end(this->buttons); ++it) {
    (*it)->getProcessThread()->join();
  } 
}

Buttons::~Buttons() {
  for(std::vector<Button*>::iterator it = std::begin(this->buttons); it != std::end(this->buttons); ++it) {
    delete (*it);
  } 
}

/*

function delay(delayInms) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(2);
    }, delayInms);
  });
}

async function click(nbclick, input = "DI2", d = 50) {
  var delayres;
  for(i=0; i<nbclick; i++) {
    wsClientPublish({"state":"ON"}, "HousePLC/Digital_Inputs/"+input,0);
    delayres = await delay(d);
    wsClientPublish({"state":"OFF"}, "HousePLC/Digital_Inputs/"+input,0);
    delayres = await delay(d);
  }
  console.log('finished');
}

*/